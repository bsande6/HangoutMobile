{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnFieldsSelector, gridColumnDefinitionsSelector, gridColumnLookupSelector, gridColumnsMetaSelector, gridColumnsSelector, gridColumnVisibilityModelSelector, gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from './gridColumnsSelector';\nimport { useGridApiEventHandler, useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridRegisterPreProcessor } from '../../core/preProcessing';\nimport { hydrateColumnsWidth, computeColumnTypes, createColumnsState, setColumnsState } from './gridColumnsUtils';\nexport const columnsStateInitializer = (state, props, apiRef) => {\n  var _props$initialState, _props$initialState$c, _ref, _props$columnVisibili, _props$initialState2, _props$initialState2$;\n\n  const shouldUseVisibleColumnModel = !!props.columnVisibilityModel || !!((_props$initialState = props.initialState) != null && (_props$initialState$c = _props$initialState.columns) != null && _props$initialState$c.columnVisibilityModel);\n  const columnsTypes = computeColumnTypes(props.columnTypes);\n  const columnsState = createColumnsState({\n    apiRef,\n    columnsTypes,\n    columnsToUpsert: props.columns,\n    shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n    currentColumnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.columns) == null ? void 0 : _props$initialState2$.columnVisibilityModel) != null ? _ref : {},\n    reset: true\n  });\n  return _extends({}, state, {\n    columns: columnsState\n  });\n};\n/**\n * @requires useGridParamsApi (method)\n * @requires useGridDimensions (method, event) - can be after\n * TODO: Impossible priority - useGridParamsApi also needs to be after useGridColumns\n */\n\nexport function useGridColumns(apiRef, props) {\n  var _props$initialState3, _props$initialState3$;\n\n  const logger = useGridLogger(apiRef, 'useGridColumns');\n  const columnsTypes = React.useMemo(() => computeColumnTypes(props.columnTypes), [props.columnTypes]);\n  /**\n   * If `initialState.columns.columnVisibilityModel` or `columnVisibilityModel` was defined during the 1st render, we are directly updating the model\n   * If not, we keep the old behavior and update the `GridColDef.hide` option (which will update the state model through the `GridColDef.hide` => `columnVisibilityModel` sync in `createColumnsState`\n   */\n\n  const shouldUseVisibleColumnModel = React.useRef(!!props.columnVisibilityModel || !!((_props$initialState3 = props.initialState) != null && (_props$initialState3$ = _props$initialState3.columns) != null && _props$initialState3$.columnVisibilityModel)).current;\n  apiRef.current.unstable_updateControlState({\n    stateId: 'visibleColumns',\n    propModel: props.columnVisibilityModel,\n    propOnChange: props.onColumnVisibilityModelChange,\n    stateSelector: gridColumnVisibilityModelSelector,\n    changeEvent: GridEvents.columnVisibilityModelChange\n  });\n  const setGridColumnsState = React.useCallback(columnsState => {\n    logger.debug('Updating columns state.');\n    apiRef.current.setState(setColumnsState(columnsState));\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.columnsChange, columnsState.all);\n  }, [logger, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const getColumn = React.useCallback(field => gridColumnLookupSelector(apiRef)[field], [apiRef]);\n  const getAllColumns = React.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getVisibleColumns = React.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getColumnsMeta = React.useCallback(() => gridColumnsMetaSelector(apiRef), [apiRef]);\n  const getColumnIndex = React.useCallback(function (field) {\n    let useVisibleColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);\n    return columns.findIndex(col => col.field === field);\n  }, [apiRef]);\n  const getColumnPosition = React.useCallback(field => {\n    const index = getColumnIndex(field);\n    return gridColumnPositionsSelector(apiRef)[index];\n  }, [apiRef, getColumnIndex]);\n  const setColumnVisibilityModel = React.useCallback(model => {\n    const currentModel = gridColumnVisibilityModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      apiRef.current.setState(state => _extends({}, state, {\n        columns: createColumnsState({\n          apiRef,\n          columnsTypes,\n          columnsToUpsert: [],\n          shouldRegenColumnVisibilityModelFromColumns: false,\n          currentColumnVisibilityModel: model,\n          reset: false\n        })\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, columnsTypes]);\n  const updateColumns = React.useCallback(columns => {\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: columns,\n      shouldRegenColumnVisibilityModelFromColumns: true,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, setGridColumnsState, columnsTypes]);\n  const updateColumn = React.useCallback(column => apiRef.current.updateColumns([column]), [apiRef]);\n  const setColumnVisibility = React.useCallback((field, isVisible) => {\n    // We keep updating the `hide` option of `GridColDef` when not controlling the model to avoid any breaking change.\n    // `updateColumns` take care of updating the model itself if needs be.\n    // TODO v6: stop using the `hide` field even when the model is not defined\n    if (shouldUseVisibleColumnModel) {\n      var _columnVisibilityMode;\n\n      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);\n      const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;\n\n      if (isVisible !== isCurrentlyVisible) {\n        const newModel = _extends({}, columnVisibilityModel, {\n          [field]: isVisible\n        });\n\n        apiRef.current.setColumnVisibilityModel(newModel);\n      }\n    } else {\n      const column = apiRef.current.getColumn(field);\n\n      const newColumn = _extends({}, column, {\n        hide: !isVisible\n      });\n\n      apiRef.current.updateColumns([newColumn]);\n      const params = {\n        field,\n        colDef: newColumn,\n        isVisible\n      };\n      apiRef.current.publishEvent(GridEvents.columnVisibilityChange, params);\n    }\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const setColumnIndex = React.useCallback((field, targetIndexPosition) => {\n    const allColumns = gridColumnFieldsSelector(apiRef);\n    const oldIndexPosition = allColumns.findIndex(col => col === field);\n\n    if (oldIndexPosition === targetIndexPosition) {\n      return;\n    }\n\n    logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);\n    const updatedColumns = [...allColumns];\n    updatedColumns.splice(targetIndexPosition, 0, updatedColumns.splice(oldIndexPosition, 1)[0]);\n    setGridColumnsState(_extends({}, gridColumnsSelector(apiRef.current.state), {\n      all: updatedColumns\n    }));\n    const params = {\n      field,\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: apiRef.current.getColumn(field),\n      targetIndex: targetIndexPosition,\n      oldIndex: oldIndexPosition\n    };\n    apiRef.current.publishEvent(GridEvents.columnOrderChange, params);\n  }, [apiRef, logger, setGridColumnsState]);\n  const setColumnWidth = React.useCallback((field, width) => {\n    logger.debug(`Updating column ${field} width to ${width}`);\n    const column = apiRef.current.getColumn(field);\n\n    const newColumn = _extends({}, column, {\n      width\n    });\n\n    apiRef.current.updateColumns([newColumn]);\n    apiRef.current.publishEvent(GridEvents.columnWidthChange, {\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: newColumn,\n      width\n    });\n  }, [apiRef, logger]);\n  const columnApi = {\n    getColumn,\n    getAllColumns,\n    getColumnIndex,\n    getColumnPosition,\n    getVisibleColumns,\n    getColumnsMeta,\n    updateColumn,\n    updateColumns,\n    setColumnVisibilityModel,\n    setColumnVisibility,\n    setColumnIndex,\n    setColumnWidth\n  };\n  useGridApiMethod(apiRef, columnApi, 'GridColumnApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  const stateExportPreProcessing = React.useCallback(prevState => {\n    if (!shouldUseVisibleColumnModel) {\n      return prevState;\n    }\n\n    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);\n    const hasHiddenColumns = Object.values(columnVisibilityModelToExport).some(value => value === false);\n\n    if (!hasHiddenColumns) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      columns: {\n        columnVisibilityModel: columnVisibilityModelToExport\n      }\n    });\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    var _context$stateToResto;\n\n    if (!shouldUseVisibleColumnModel) {\n      return params;\n    }\n\n    const columnVisibilityModel = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;\n\n    if (columnVisibilityModel != null) {\n      const columnsState = createColumnsState({\n        apiRef,\n        columnsTypes,\n        columnsToUpsert: [],\n        shouldRegenColumnVisibilityModelFromColumns: false,\n        currentColumnVisibilityModel: columnVisibilityModel,\n        reset: false\n      });\n      apiRef.current.setState(setColumnsState(columnsState));\n    }\n\n    return params;\n  }, [apiRef, shouldUseVisibleColumnModel, columnsTypes]);\n  useGridRegisterPreProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPreProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  /**\n   * EVENTS\n   */\n\n  const handlePreProcessorRegister = React.useCallback(name => {\n    if (name !== 'hydrateColumns') {\n      return;\n    }\n\n    logger.info(`Columns pre-processing have changed, regenerating the columns`);\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: [],\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, logger, setGridColumnsState, columnsTypes, shouldUseVisibleColumnModel]);\n  const prevInnerWidth = React.useRef(null);\n\n  const handleGridSizeChange = viewportInnerSize => {\n    if (prevInnerWidth.current !== viewportInnerSize.width) {\n      prevInnerWidth.current = viewportInnerSize.width;\n      setGridColumnsState(hydrateColumnsWidth(gridColumnsSelector(apiRef.current.state), viewportInnerSize.width));\n    }\n  };\n\n  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);\n  useGridApiEventHandler(apiRef, GridEvents.viewportInnerSizeChange, handleGridSizeChange);\n  useGridApiOptionHandler(apiRef, GridEvents.columnVisibilityChange, props.onColumnVisibilityChange);\n  /**\n   * EFFECTS\n   */\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    logger.info(`GridColumns have changed, new length ${props.columns.length}`);\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      columnsToUpsert: props.columns,\n      reset: true\n    });\n    setGridColumnsState(columnsState);\n  }, [logger, apiRef, setGridColumnsState, props.columns, columnsTypes, shouldUseVisibleColumnModel]);\n  React.useEffect(() => {\n    if (props.columnVisibilityModel !== undefined) {\n      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);\n    }\n  }, [apiRef, logger, props.columnVisibilityModel]);\n}","map":{"version":3,"sources":["/Users/kenleyshaw 1/Desktop/school/visual studio/HangoutApp/frontend/node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumns.js"],"names":["_extends","React","GridEvents","useGridApiMethod","useGridLogger","gridColumnFieldsSelector","gridColumnDefinitionsSelector","gridColumnLookupSelector","gridColumnsMetaSelector","gridColumnsSelector","gridColumnVisibilityModelSelector","gridVisibleColumnDefinitionsSelector","gridColumnPositionsSelector","useGridApiEventHandler","useGridApiOptionHandler","useGridRegisterPreProcessor","hydrateColumnsWidth","computeColumnTypes","createColumnsState","setColumnsState","columnsStateInitializer","state","props","apiRef","_props$initialState","_props$initialState$c","_ref","_props$columnVisibili","_props$initialState2","_props$initialState2$","shouldUseVisibleColumnModel","columnVisibilityModel","initialState","columns","columnsTypes","columnTypes","columnsState","columnsToUpsert","shouldRegenColumnVisibilityModelFromColumns","currentColumnVisibilityModel","reset","useGridColumns","_props$initialState3","_props$initialState3$","logger","useMemo","useRef","current","unstable_updateControlState","stateId","propModel","propOnChange","onColumnVisibilityModelChange","stateSelector","changeEvent","columnVisibilityModelChange","setGridColumnsState","useCallback","debug","setState","forceUpdate","publishEvent","columnsChange","all","getColumn","field","getAllColumns","getVisibleColumns","getColumnsMeta","getColumnIndex","useVisibleColumns","findIndex","col","getColumnPosition","index","setColumnVisibilityModel","model","currentModel","updateColumns","updateColumn","column","setColumnVisibility","isVisible","_columnVisibilityMode","isCurrentlyVisible","newModel","newColumn","hide","params","colDef","columnVisibilityChange","setColumnIndex","targetIndexPosition","allColumns","oldIndexPosition","updatedColumns","splice","element","getColumnHeaderElement","targetIndex","oldIndex","columnOrderChange","setColumnWidth","width","columnWidthChange","columnApi","stateExportPreProcessing","prevState","columnVisibilityModelToExport","hasHiddenColumns","Object","values","some","value","stateRestorePreProcessing","context","_context$stateToResto","stateToRestore","handlePreProcessorRegister","name","info","prevInnerWidth","handleGridSizeChange","viewportInnerSize","preProcessorRegister","viewportInnerSizeChange","onColumnVisibilityChange","isFirstRender","useEffect","length","undefined"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnFieldsSelector, gridColumnDefinitionsSelector, gridColumnLookupSelector, gridColumnsMetaSelector, gridColumnsSelector, gridColumnVisibilityModelSelector, gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from './gridColumnsSelector';\nimport { useGridApiEventHandler, useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridRegisterPreProcessor } from '../../core/preProcessing';\nimport { hydrateColumnsWidth, computeColumnTypes, createColumnsState, setColumnsState } from './gridColumnsUtils';\nexport const columnsStateInitializer = (state, props, apiRef) => {\n  var _props$initialState, _props$initialState$c, _ref, _props$columnVisibili, _props$initialState2, _props$initialState2$;\n\n  const shouldUseVisibleColumnModel = !!props.columnVisibilityModel || !!((_props$initialState = props.initialState) != null && (_props$initialState$c = _props$initialState.columns) != null && _props$initialState$c.columnVisibilityModel);\n  const columnsTypes = computeColumnTypes(props.columnTypes);\n  const columnsState = createColumnsState({\n    apiRef,\n    columnsTypes,\n    columnsToUpsert: props.columns,\n    shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n    currentColumnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.columns) == null ? void 0 : _props$initialState2$.columnVisibilityModel) != null ? _ref : {},\n    reset: true\n  });\n  return _extends({}, state, {\n    columns: columnsState\n  });\n};\n/**\n * @requires useGridParamsApi (method)\n * @requires useGridDimensions (method, event) - can be after\n * TODO: Impossible priority - useGridParamsApi also needs to be after useGridColumns\n */\n\nexport function useGridColumns(apiRef, props) {\n  var _props$initialState3, _props$initialState3$;\n\n  const logger = useGridLogger(apiRef, 'useGridColumns');\n  const columnsTypes = React.useMemo(() => computeColumnTypes(props.columnTypes), [props.columnTypes]);\n  /**\n   * If `initialState.columns.columnVisibilityModel` or `columnVisibilityModel` was defined during the 1st render, we are directly updating the model\n   * If not, we keep the old behavior and update the `GridColDef.hide` option (which will update the state model through the `GridColDef.hide` => `columnVisibilityModel` sync in `createColumnsState`\n   */\n\n  const shouldUseVisibleColumnModel = React.useRef(!!props.columnVisibilityModel || !!((_props$initialState3 = props.initialState) != null && (_props$initialState3$ = _props$initialState3.columns) != null && _props$initialState3$.columnVisibilityModel)).current;\n  apiRef.current.unstable_updateControlState({\n    stateId: 'visibleColumns',\n    propModel: props.columnVisibilityModel,\n    propOnChange: props.onColumnVisibilityModelChange,\n    stateSelector: gridColumnVisibilityModelSelector,\n    changeEvent: GridEvents.columnVisibilityModelChange\n  });\n  const setGridColumnsState = React.useCallback(columnsState => {\n    logger.debug('Updating columns state.');\n    apiRef.current.setState(setColumnsState(columnsState));\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.columnsChange, columnsState.all);\n  }, [logger, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const getColumn = React.useCallback(field => gridColumnLookupSelector(apiRef)[field], [apiRef]);\n  const getAllColumns = React.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getVisibleColumns = React.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getColumnsMeta = React.useCallback(() => gridColumnsMetaSelector(apiRef), [apiRef]);\n  const getColumnIndex = React.useCallback((field, useVisibleColumns = true) => {\n    const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);\n    return columns.findIndex(col => col.field === field);\n  }, [apiRef]);\n  const getColumnPosition = React.useCallback(field => {\n    const index = getColumnIndex(field);\n    return gridColumnPositionsSelector(apiRef)[index];\n  }, [apiRef, getColumnIndex]);\n  const setColumnVisibilityModel = React.useCallback(model => {\n    const currentModel = gridColumnVisibilityModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      apiRef.current.setState(state => _extends({}, state, {\n        columns: createColumnsState({\n          apiRef,\n          columnsTypes,\n          columnsToUpsert: [],\n          shouldRegenColumnVisibilityModelFromColumns: false,\n          currentColumnVisibilityModel: model,\n          reset: false\n        })\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, columnsTypes]);\n  const updateColumns = React.useCallback(columns => {\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: columns,\n      shouldRegenColumnVisibilityModelFromColumns: true,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, setGridColumnsState, columnsTypes]);\n  const updateColumn = React.useCallback(column => apiRef.current.updateColumns([column]), [apiRef]);\n  const setColumnVisibility = React.useCallback((field, isVisible) => {\n    // We keep updating the `hide` option of `GridColDef` when not controlling the model to avoid any breaking change.\n    // `updateColumns` take care of updating the model itself if needs be.\n    // TODO v6: stop using the `hide` field even when the model is not defined\n    if (shouldUseVisibleColumnModel) {\n      var _columnVisibilityMode;\n\n      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);\n      const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;\n\n      if (isVisible !== isCurrentlyVisible) {\n        const newModel = _extends({}, columnVisibilityModel, {\n          [field]: isVisible\n        });\n\n        apiRef.current.setColumnVisibilityModel(newModel);\n      }\n    } else {\n      const column = apiRef.current.getColumn(field);\n\n      const newColumn = _extends({}, column, {\n        hide: !isVisible\n      });\n\n      apiRef.current.updateColumns([newColumn]);\n      const params = {\n        field,\n        colDef: newColumn,\n        isVisible\n      };\n      apiRef.current.publishEvent(GridEvents.columnVisibilityChange, params);\n    }\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const setColumnIndex = React.useCallback((field, targetIndexPosition) => {\n    const allColumns = gridColumnFieldsSelector(apiRef);\n    const oldIndexPosition = allColumns.findIndex(col => col === field);\n\n    if (oldIndexPosition === targetIndexPosition) {\n      return;\n    }\n\n    logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);\n    const updatedColumns = [...allColumns];\n    updatedColumns.splice(targetIndexPosition, 0, updatedColumns.splice(oldIndexPosition, 1)[0]);\n    setGridColumnsState(_extends({}, gridColumnsSelector(apiRef.current.state), {\n      all: updatedColumns\n    }));\n    const params = {\n      field,\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: apiRef.current.getColumn(field),\n      targetIndex: targetIndexPosition,\n      oldIndex: oldIndexPosition\n    };\n    apiRef.current.publishEvent(GridEvents.columnOrderChange, params);\n  }, [apiRef, logger, setGridColumnsState]);\n  const setColumnWidth = React.useCallback((field, width) => {\n    logger.debug(`Updating column ${field} width to ${width}`);\n    const column = apiRef.current.getColumn(field);\n\n    const newColumn = _extends({}, column, {\n      width\n    });\n\n    apiRef.current.updateColumns([newColumn]);\n    apiRef.current.publishEvent(GridEvents.columnWidthChange, {\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: newColumn,\n      width\n    });\n  }, [apiRef, logger]);\n  const columnApi = {\n    getColumn,\n    getAllColumns,\n    getColumnIndex,\n    getColumnPosition,\n    getVisibleColumns,\n    getColumnsMeta,\n    updateColumn,\n    updateColumns,\n    setColumnVisibilityModel,\n    setColumnVisibility,\n    setColumnIndex,\n    setColumnWidth\n  };\n  useGridApiMethod(apiRef, columnApi, 'GridColumnApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  const stateExportPreProcessing = React.useCallback(prevState => {\n    if (!shouldUseVisibleColumnModel) {\n      return prevState;\n    }\n\n    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);\n    const hasHiddenColumns = Object.values(columnVisibilityModelToExport).some(value => value === false);\n\n    if (!hasHiddenColumns) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      columns: {\n        columnVisibilityModel: columnVisibilityModelToExport\n      }\n    });\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    var _context$stateToResto;\n\n    if (!shouldUseVisibleColumnModel) {\n      return params;\n    }\n\n    const columnVisibilityModel = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;\n\n    if (columnVisibilityModel != null) {\n      const columnsState = createColumnsState({\n        apiRef,\n        columnsTypes,\n        columnsToUpsert: [],\n        shouldRegenColumnVisibilityModelFromColumns: false,\n        currentColumnVisibilityModel: columnVisibilityModel,\n        reset: false\n      });\n      apiRef.current.setState(setColumnsState(columnsState));\n    }\n\n    return params;\n  }, [apiRef, shouldUseVisibleColumnModel, columnsTypes]);\n  useGridRegisterPreProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPreProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  /**\n   * EVENTS\n   */\n\n  const handlePreProcessorRegister = React.useCallback(name => {\n    if (name !== 'hydrateColumns') {\n      return;\n    }\n\n    logger.info(`Columns pre-processing have changed, regenerating the columns`);\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: [],\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, logger, setGridColumnsState, columnsTypes, shouldUseVisibleColumnModel]);\n  const prevInnerWidth = React.useRef(null);\n\n  const handleGridSizeChange = viewportInnerSize => {\n    if (prevInnerWidth.current !== viewportInnerSize.width) {\n      prevInnerWidth.current = viewportInnerSize.width;\n      setGridColumnsState(hydrateColumnsWidth(gridColumnsSelector(apiRef.current.state), viewportInnerSize.width));\n    }\n  };\n\n  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);\n  useGridApiEventHandler(apiRef, GridEvents.viewportInnerSizeChange, handleGridSizeChange);\n  useGridApiOptionHandler(apiRef, GridEvents.columnVisibilityChange, props.onColumnVisibilityChange);\n  /**\n   * EFFECTS\n   */\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    logger.info(`GridColumns have changed, new length ${props.columns.length}`);\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      columnsToUpsert: props.columns,\n      reset: true\n    });\n    setGridColumnsState(columnsState);\n  }, [logger, apiRef, setGridColumnsState, props.columns, columnsTypes, shouldUseVisibleColumnModel]);\n  React.useEffect(() => {\n    if (props.columnVisibilityModel !== undefined) {\n      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);\n    }\n  }, [apiRef, logger, props.columnVisibilityModel]);\n}"]},"metadata":{},"sourceType":"module"}