{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../models';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const computeColumnTypes = function () {\n  let customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const allColumnTypes = _extends({}, getGridDefaultColumnTypes(), customColumnTypes);\n\n  const mergedColumnTypes = {};\n  Object.entries(allColumnTypes).forEach(_ref => {\n    let [colType, colTypeDef] = _ref;\n    colTypeDef = _extends({}, allColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    mergedColumnTypes[colType] = colTypeDef;\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref2) {\n  let {\n    initialFreeSpace,\n    totalFlexUnits,\n    flexColumns\n  } = _ref2;\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(_ref3 => {\n        let {\n          field\n        } = _ref3;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = _ref4 => {\n  let {\n    apiRef,\n    columnsToUpsert,\n    columnsTypes,\n    currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n    shouldRegenColumnVisibilityModelFromColumns,\n    reset\n  } = _ref4;\n\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (reset) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [...currentState.all],\n      lookup: _extends({}, currentState.lookup)\n    };\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    columnsToUpsertLookup[newColumn.field] = true;\n\n    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {\n      // New Column\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, getGridColDef(columnsTypes, newColumn.type), newColumn);\n      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);\n    } else {\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);\n    }\n  });\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    if (reset) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        columnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else {\n      const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n      let hasModelChanged = false;\n      columnsStateWithPreProcessing.all.forEach(field => {\n        var _currentColumnVisibil; // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n        // Then we don't want to update the visibility status of the column in the model.\n\n\n        if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n          return;\n        }\n\n        const isVisibleBefore = (_currentColumnVisibil = currentColumnVisibilityModel[field]) != null ? _currentColumnVisibil : true;\n        const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n        if (isVisibleAfter !== isVisibleBefore) {\n          hasModelChanged = true;\n          newColumnVisibilityModel[field] = isVisibleAfter;\n        }\n      });\n\n      if (hasModelChanged) {\n        columnVisibilityModel = newColumnVisibilityModel;\n      } else {\n        columnVisibilityModel = currentColumnVisibilityModel;\n      }\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsState = _extends({}, columnsStateWithPreProcessing, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const setColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});","map":{"version":3,"sources":["/Users/kenleyshaw 1/Desktop/school/visual studio/HangoutApp/frontend/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","getGridDefaultColumnTypes","gridColumnsSelector","gridColumnVisibilityModelSelector","clamp","computeColumnTypes","customColumnTypes","allColumnTypes","mergedColumnTypes","Object","entries","forEach","colType","colTypeDef","extendType","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","keys","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","columnTypeWarnedOnce","getGridColDef","columnTypes","type","process","env","NODE_ENV","console","warn","join","createColumnsState","apiRef","columnsToUpsert","columnsTypes","currentColumnVisibilityModel","shouldRegenColumnVisibilityModelFromColumns","reset","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","columnsStateWithoutColumnVisibilityModel","currentState","current","state","columnsToUpsertLookup","columnsLookupBeforePreProcessing","columnsStateWithPreProcessing","unstable_applyPreProcessors","hide","newColumnVisibilityModel","hasModelChanged","_currentColumnVisibil","isVisibleBefore","isVisibleAfter","columnsState","getRootDimensions","call","viewportInnerSize","setColumnsState","columns"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../models';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const computeColumnTypes = (customColumnTypes = {}) => {\n  const allColumnTypes = _extends({}, getGridDefaultColumnTypes(), customColumnTypes);\n\n  const mergedColumnTypes = {};\n  Object.entries(allColumnTypes).forEach(([colType, colTypeDef]) => {\n    colTypeDef = _extends({}, allColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    mergedColumnTypes[colType] = colTypeDef;\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  columnsTypes,\n  currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  shouldRegenColumnVisibilityModelFromColumns,\n  reset\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (reset) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [...currentState.all],\n      lookup: _extends({}, currentState.lookup)\n    };\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    columnsToUpsertLookup[newColumn.field] = true;\n\n    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {\n      // New Column\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, getGridColDef(columnsTypes, newColumn.type), newColumn);\n      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);\n    } else {\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);\n    }\n  });\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    if (reset) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        columnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else {\n      const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n      let hasModelChanged = false;\n      columnsStateWithPreProcessing.all.forEach(field => {\n        var _currentColumnVisibil;\n\n        // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n        // Then we don't want to update the visibility status of the column in the model.\n        if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n          return;\n        }\n\n        const isVisibleBefore = (_currentColumnVisibil = currentColumnVisibilityModel[field]) != null ? _currentColumnVisibil : true;\n        const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n        if (isVisibleAfter !== isVisibleBefore) {\n          hasModelChanged = true;\n          newColumnVisibilityModel[field] = isVisibleAfter;\n        }\n      });\n\n      if (hasModelChanged) {\n        columnVisibilityModel = newColumnVisibilityModel;\n      } else {\n        columnVisibilityModel = currentColumnVisibilityModel;\n      }\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsState = _extends({}, columnsStateWithPreProcessing, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const setColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});"]},"metadata":{},"sourceType":"module"}