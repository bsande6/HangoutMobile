{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLinkOperator } from '../../../models';\nimport { buildWarning } from '../../../utils/warning';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operatorValue.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\n\nconst cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operatorValue == null) {\n    // we select a default operator\n    const column = apiRef.current.getColumn(cleanItem.columnField);\n    cleanItem.operatorValue = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\n\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning(\"MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.\", 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning(['MUI: One of your filtering item have no `operatorValue` provided.', 'This property will become required on `@mui/x-data-grid@6.X`.']);\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operatorValue == null);\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => state => _extends({}, state, {\n  filter: _extends({}, state.filter, {\n    filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n  })\n});\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport const buildAggregatedFilterApplier = (filterModel, apiRef) => {\n  const {\n    items,\n    linkOperator = GridLinkOperator.And\n  } = filterModel;\n\n  const getFilterCallbackFromItem = filterItem => {\n    if (!filterItem.columnField || !filterItem.operatorValue) {\n      return null;\n    }\n\n    const column = apiRef.current.getColumn(filterItem.columnField);\n\n    if (!column) {\n      return null;\n    }\n\n    let parsedValue;\n\n    if (column.valueParser) {\n      var _filterItem$value;\n\n      const parser = column.valueParser;\n      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n    } else {\n      parsedValue = filterItem.value;\n    }\n\n    const newFilterItem = _extends({}, filterItem, {\n      value: parsedValue\n    });\n\n    const filterOperators = column.filterOperators;\n\n    if (!(filterOperators != null && filterOperators.length)) {\n      throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n    }\n\n    const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operatorValue);\n\n    if (!filterOperator) {\n      throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operatorValue}'.`);\n    }\n\n    const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n\n    const fn = rowId => {\n      const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.columnField);\n      return applyFilterOnRow(cellParams);\n    };\n\n    return {\n      fn,\n      item: newFilterItem\n    };\n  };\n\n  const appliers = items.map(getFilterCallbackFromItem).filter(callback => !!callback);\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  return (rowId, shouldApplyFilter) => {\n    const filteredAppliers = shouldApplyFilter ? appliers.filter(applier => shouldApplyFilter(applier.item)) : appliers; // Return `false` as soon as we have a failing filter\n\n    if (linkOperator === GridLinkOperator.And) {\n      return filteredAppliers.every(applier => applier.fn(rowId));\n    } // Return `true` as soon as we have a passing filter\n\n\n    return filteredAppliers.some(applier => applier.fn(rowId));\n  };\n};","map":{"version":3,"sources":["/Users/kenleyshaw 1/Desktop/school/visual studio/HangoutApp/frontend/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"names":["_extends","GridLinkOperator","buildWarning","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operatorValue","column","current","getColumn","columnField","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","state","filter","buildAggregatedFilterApplier","linkOperator","And","getFilterCallbackFromItem","filterItem","parsedValue","valueParser","_filterItem$value","parser","Array","isArray","x","newFilterItem","Error","field","filterOperator","find","operator","applyFilterOnRow","getApplyFilterFn","fn","rowId","cellParams","getCellParams","appliers","callback","shouldApplyFilter","filteredAppliers","applier","every"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,SAASC,YAAT,QAA6B,wBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,eAAe,GAAG,CAACC,IAAD,EAAOC,MAAP,KAAkB;AACxC,QAAMC,SAAS,GAAGN,QAAQ,CAAC,EAAD,EAAKI,IAAL,CAA1B;;AAEA,MAAIE,SAAS,CAACC,EAAV,IAAgB,IAApB,EAA0B;AACxBD,IAAAA,SAAS,CAACC,EAAV,GAAeC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,GAA3B,CAAf;AACD;;AAED,MAAIJ,SAAS,CAACK,aAAV,IAA2B,IAA/B,EAAqC;AACnC;AACA,UAAMC,MAAM,GAAGP,MAAM,CAACQ,OAAP,CAAeC,SAAf,CAAyBR,SAAS,CAACS,WAAnC,CAAf;AACAT,IAAAA,SAAS,CAACK,aAAV,GAA0BC,MAAM,IAAIA,MAAM,CAACI,eAAP,CAAuB,CAAvB,EAA0BC,KAA9D;AACD;;AAED,SAAOX,SAAP;AACD,CAdD;;AAgBA,MAAMY,8CAA8C,GAAGhB,YAAY,CAAC,CAAC,yHAAD,EAA4H,uFAA5H,CAAD,EAAuN,OAAvN,CAAnE;AACA,MAAMiB,+BAA+B,GAAGjB,YAAY,CAAC,uFAAD,EAA0F,OAA1F,CAApD;AACA,MAAMkB,qCAAqC,GAAGlB,YAAY,CAAC,CAAC,mEAAD,EAAsE,+DAAtE,CAAD,CAA1D;AACA,OAAO,MAAMmB,mBAAmB,GAAG,CAACC,KAAD,EAAQC,+BAAR,EAAyClB,MAAzC,KAAoD;AACrF,QAAMmB,eAAe,GAAGF,KAAK,CAACG,KAAN,CAAYC,MAAZ,GAAqB,CAA7C;AACA,MAAID,KAAJ;;AAEA,MAAID,eAAe,IAAID,+BAAvB,EAAwD;AACtDL,IAAAA,8CAA8C;AAC9CO,IAAAA,KAAK,GAAG,CAACH,KAAK,CAACG,KAAN,CAAY,CAAZ,CAAD,CAAR;AACD,GAHD,MAGO;AACLA,IAAAA,KAAK,GAAGH,KAAK,CAACG,KAAd;AACD;;AAED,QAAME,kBAAkB,GAAGH,eAAe,IAAIC,KAAK,CAACG,IAAN,CAAWxB,IAAI,IAAIA,IAAI,CAACG,EAAL,IAAW,IAA9B,CAA9C;AACA,QAAMsB,sBAAsB,GAAGJ,KAAK,CAACG,IAAN,CAAWxB,IAAI,IAAIA,IAAI,CAACO,aAAL,IAAsB,IAAzC,CAA/B;;AAEA,MAAIgB,kBAAJ,EAAwB;AACtBR,IAAAA,+BAA+B;AAChC;;AAED,MAAIU,sBAAJ,EAA4B;AAC1BT,IAAAA,qCAAqC;AACtC;;AAED,MAAIS,sBAAsB,IAAIF,kBAA9B,EAAkD;AAChD,WAAO3B,QAAQ,CAAC,EAAD,EAAKsB,KAAL,EAAY;AACzBG,MAAAA,KAAK,EAAEA,KAAK,CAACK,GAAN,CAAU1B,IAAI,IAAID,eAAe,CAACC,IAAD,EAAOC,MAAP,CAAjC;AADkB,KAAZ,CAAf;AAGD;;AAED,MAAIiB,KAAK,CAACG,KAAN,KAAgBA,KAApB,EAA2B;AACzB,WAAOzB,QAAQ,CAAC,EAAD,EAAKsB,KAAL,EAAY;AACzBG,MAAAA;AADyB,KAAZ,CAAf;AAGD;;AAED,SAAOH,KAAP;AACD,CAnCM;AAoCP,OAAO,MAAMS,yBAAyB,GAAG,CAACC,WAAD,EAAcT,+BAAd,EAA+ClB,MAA/C,KAA0D4B,KAAK,IAAIjC,QAAQ,CAAC,EAAD,EAAKiC,KAAL,EAAY;AAC9HC,EAAAA,MAAM,EAAElC,QAAQ,CAAC,EAAD,EAAKiC,KAAK,CAACC,MAAX,EAAmB;AACjCF,IAAAA,WAAW,EAAEX,mBAAmB,CAACW,WAAD,EAAcT,+BAAd,EAA+ClB,MAA/C;AADC,GAAnB;AAD8G,CAAZ,CAA7G;AAKP;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAM8B,4BAA4B,GAAG,CAACH,WAAD,EAAc3B,MAAd,KAAyB;AACnE,QAAM;AACJoB,IAAAA,KADI;AAEJW,IAAAA,YAAY,GAAGnC,gBAAgB,CAACoC;AAF5B,MAGFL,WAHJ;;AAKA,QAAMM,yBAAyB,GAAGC,UAAU,IAAI;AAC9C,QAAI,CAACA,UAAU,CAACxB,WAAZ,IAA2B,CAACwB,UAAU,CAAC5B,aAA3C,EAA0D;AACxD,aAAO,IAAP;AACD;;AAED,UAAMC,MAAM,GAAGP,MAAM,CAACQ,OAAP,CAAeC,SAAf,CAAyByB,UAAU,CAACxB,WAApC,CAAf;;AAEA,QAAI,CAACH,MAAL,EAAa;AACX,aAAO,IAAP;AACD;;AAED,QAAI4B,WAAJ;;AAEA,QAAI5B,MAAM,CAAC6B,WAAX,EAAwB;AACtB,UAAIC,iBAAJ;;AAEA,YAAMC,MAAM,GAAG/B,MAAM,CAAC6B,WAAtB;AACAD,MAAAA,WAAW,GAAGI,KAAK,CAACC,OAAN,CAAcN,UAAU,CAACtB,KAAzB,IAAkC,CAACyB,iBAAiB,GAAGH,UAAU,CAACtB,KAAhC,KAA0C,IAA1C,GAAiD,KAAK,CAAtD,GAA0DyB,iBAAiB,CAACZ,GAAlB,CAAsBgB,CAAC,IAAIH,MAAM,CAACG,CAAD,CAAjC,CAA5F,GAAoIH,MAAM,CAACJ,UAAU,CAACtB,KAAZ,CAAxJ;AACD,KALD,MAKO;AACLuB,MAAAA,WAAW,GAAGD,UAAU,CAACtB,KAAzB;AACD;;AAED,UAAM8B,aAAa,GAAG/C,QAAQ,CAAC,EAAD,EAAKuC,UAAL,EAAiB;AAC7CtB,MAAAA,KAAK,EAAEuB;AADsC,KAAjB,CAA9B;;AAIA,UAAMxB,eAAe,GAAGJ,MAAM,CAACI,eAA/B;;AAEA,QAAI,EAAEA,eAAe,IAAI,IAAnB,IAA2BA,eAAe,CAACU,MAA7C,CAAJ,EAA0D;AACxD,YAAM,IAAIsB,KAAJ,CAAW,8CAA6CpC,MAAM,CAACqC,KAAM,IAArE,CAAN;AACD;;AAED,UAAMC,cAAc,GAAGlC,eAAe,CAACmC,IAAhB,CAAqBC,QAAQ,IAAIA,QAAQ,CAACnC,KAAT,KAAmB8B,aAAa,CAACpC,aAAlE,CAAvB;;AAEA,QAAI,CAACuC,cAAL,EAAqB;AACnB,YAAM,IAAIF,KAAJ,CAAW,6CAA4CpC,MAAM,CAACqC,KAAM,yBAAwBF,aAAa,CAACpC,aAAc,IAAxH,CAAN;AACD;;AAED,UAAM0C,gBAAgB,GAAGH,cAAc,CAACI,gBAAf,CAAgCP,aAAhC,EAA+CnC,MAA/C,CAAzB;;AAEA,QAAI,OAAOyC,gBAAP,KAA4B,UAAhC,EAA4C;AAC1C,aAAO,IAAP;AACD;;AAED,UAAME,EAAE,GAAGC,KAAK,IAAI;AAClB,YAAMC,UAAU,GAAGpD,MAAM,CAACQ,OAAP,CAAe6C,aAAf,CAA6BF,KAA7B,EAAoCT,aAAa,CAAChC,WAAlD,CAAnB;AACA,aAAOsC,gBAAgB,CAACI,UAAD,CAAvB;AACD,KAHD;;AAKA,WAAO;AACLF,MAAAA,EADK;AAELnD,MAAAA,IAAI,EAAE2C;AAFD,KAAP;AAID,GArDD;;AAuDA,QAAMY,QAAQ,GAAGlC,KAAK,CAACK,GAAN,CAAUQ,yBAAV,EAAqCJ,MAArC,CAA4C0B,QAAQ,IAAI,CAAC,CAACA,QAA1D,CAAjB;;AAEA,MAAID,QAAQ,CAACjC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,WAAO,IAAP;AACD;;AAED,SAAO,CAAC8B,KAAD,EAAQK,iBAAR,KAA8B;AACnC,UAAMC,gBAAgB,GAAGD,iBAAiB,GAAGF,QAAQ,CAACzB,MAAT,CAAgB6B,OAAO,IAAIF,iBAAiB,CAACE,OAAO,CAAC3D,IAAT,CAA5C,CAAH,GAAiEuD,QAA3G,CADmC,CACkF;;AAErH,QAAIvB,YAAY,KAAKnC,gBAAgB,CAACoC,GAAtC,EAA2C;AACzC,aAAOyB,gBAAgB,CAACE,KAAjB,CAAuBD,OAAO,IAAIA,OAAO,CAACR,EAAR,CAAWC,KAAX,CAAlC,CAAP;AACD,KALkC,CAKjC;;;AAGF,WAAOM,gBAAgB,CAAClC,IAAjB,CAAsBmC,OAAO,IAAIA,OAAO,CAACR,EAAR,CAAWC,KAAX,CAAjC,CAAP;AACD,GATD;AAUD,CA7EM","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLinkOperator } from '../../../models';\nimport { buildWarning } from '../../../utils/warning';\n\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operatorValue.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nconst cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operatorValue == null) {\n    // we select a default operator\n    const column = apiRef.current.getColumn(cleanItem.columnField);\n    cleanItem.operatorValue = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\n\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning(\"MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.\", 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning(['MUI: One of your filtering item have no `operatorValue` provided.', 'This property will become required on `@mui/x-data-grid@6.X`.']);\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operatorValue == null);\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => state => _extends({}, state, {\n  filter: _extends({}, state.filter, {\n    filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n  })\n});\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport const buildAggregatedFilterApplier = (filterModel, apiRef) => {\n  const {\n    items,\n    linkOperator = GridLinkOperator.And\n  } = filterModel;\n\n  const getFilterCallbackFromItem = filterItem => {\n    if (!filterItem.columnField || !filterItem.operatorValue) {\n      return null;\n    }\n\n    const column = apiRef.current.getColumn(filterItem.columnField);\n\n    if (!column) {\n      return null;\n    }\n\n    let parsedValue;\n\n    if (column.valueParser) {\n      var _filterItem$value;\n\n      const parser = column.valueParser;\n      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n    } else {\n      parsedValue = filterItem.value;\n    }\n\n    const newFilterItem = _extends({}, filterItem, {\n      value: parsedValue\n    });\n\n    const filterOperators = column.filterOperators;\n\n    if (!(filterOperators != null && filterOperators.length)) {\n      throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n    }\n\n    const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operatorValue);\n\n    if (!filterOperator) {\n      throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operatorValue}'.`);\n    }\n\n    const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n\n    const fn = rowId => {\n      const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.columnField);\n      return applyFilterOnRow(cellParams);\n    };\n\n    return {\n      fn,\n      item: newFilterItem\n    };\n  };\n\n  const appliers = items.map(getFilterCallbackFromItem).filter(callback => !!callback);\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  return (rowId, shouldApplyFilter) => {\n    const filteredAppliers = shouldApplyFilter ? appliers.filter(applier => shouldApplyFilter(applier.item)) : appliers; // Return `false` as soon as we have a failing filter\n\n    if (linkOperator === GridLinkOperator.And) {\n      return filteredAppliers.every(applier => applier.fn(rowId));\n    } // Return `true` as soon as we have a passing filter\n\n\n    return filteredAppliers.some(applier => applier.fn(rowId));\n  };\n};"]},"metadata":{},"sourceType":"module"}