{"ast":null,"code":"import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\n\nconst serialiseCellValue = (value, delimiterCharacter) => {\n  if (typeof value === 'string') {\n    const formattedValue = value.replace(/\"/g, '\"\"'); // Make sure value containing delimiter or line break won't be split into multiple rows\n\n    if ([delimiterCharacter, '\\n', '\\r'].some(delimiter => formattedValue.includes(delimiter))) {\n      return `\"${formattedValue}\"`;\n    }\n\n    return formattedValue;\n  }\n\n  return value;\n};\n\nlet warnedOnce = false;\n\nconst serialiseRow = (id, columns, getCellParams, delimiterCharacter) => columns.map(column => {\n  const cellParams = getCellParams(id, column.field);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnce && String(cellParams.formattedValue) === '[object Object]') {\n      console.warn(['MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.'].join('\\n'));\n      warnedOnce = true;\n    }\n  }\n\n  return serialiseCellValue(cellParams.formattedValue, delimiterCharacter);\n});\n\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    getCellParams,\n    delimiterCharacter,\n    includeHeaders\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => `${acc}${serialiseRow(id, columns, getCellParams, delimiterCharacter).join(delimiterCharacter)}\\r\\n`, '').trim();\n\n  if (!includeHeaders) {\n    return CSVBody;\n  }\n\n  const CSVHead = `${columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field).map(column => serialiseCellValue(column.headerName || column.field, delimiterCharacter)).join(delimiterCharacter)}\\r\\n`;\n  return `${CSVHead}${CSVBody}`.trim();\n}","map":{"version":3,"sources":["/Users/kenleyshaw 1/Desktop/school/visual studio/HangoutApp/frontend/node_modules/@mui/x-data-grid/hooks/features/export/serializers/csvSerializer.js"],"names":["GRID_CHECKBOX_SELECTION_COL_DEF","serialiseCellValue","value","delimiterCharacter","formattedValue","replace","some","delimiter","includes","warnedOnce","serialiseRow","id","columns","getCellParams","map","column","cellParams","field","process","env","NODE_ENV","String","console","warn","join","buildCSV","options","rowIds","includeHeaders","CSVBody","reduce","acc","trim","CSVHead","filter","headerName"],"mappings":"AAAA,SAASA,+BAAT,QAAgD,oBAAhD;;AAEA,MAAMC,kBAAkB,GAAG,CAACC,KAAD,EAAQC,kBAAR,KAA+B;AACxD,MAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAME,cAAc,GAAGF,KAAK,CAACG,OAAN,CAAc,IAAd,EAAoB,IAApB,CAAvB,CAD6B,CACqB;;AAElD,QAAI,CAACF,kBAAD,EAAqB,IAArB,EAA2B,IAA3B,EAAiCG,IAAjC,CAAsCC,SAAS,IAAIH,cAAc,CAACI,QAAf,CAAwBD,SAAxB,CAAnD,CAAJ,EAA4F;AAC1F,aAAQ,IAAGH,cAAe,GAA1B;AACD;;AAED,WAAOA,cAAP;AACD;;AAED,SAAOF,KAAP;AACD,CAZD;;AAcA,IAAIO,UAAU,GAAG,KAAjB;;AAEA,MAAMC,YAAY,GAAG,CAACC,EAAD,EAAKC,OAAL,EAAcC,aAAd,EAA6BV,kBAA7B,KAAoDS,OAAO,CAACE,GAAR,CAAYC,MAAM,IAAI;AAC7F,QAAMC,UAAU,GAAGH,aAAa,CAACF,EAAD,EAAKI,MAAM,CAACE,KAAZ,CAAhC;;AAEA,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAI,CAACX,UAAD,IAAeY,MAAM,CAACL,UAAU,CAACZ,cAAZ,CAAN,KAAsC,iBAAzD,EAA4E;AAC1EkB,MAAAA,OAAO,CAACC,IAAR,CAAa,CAAC,kIAAD,EAAqI,6EAArI,EAAoNC,IAApN,CAAyN,IAAzN,CAAb;AACAf,MAAAA,UAAU,GAAG,IAAb;AACD;AACF;;AAED,SAAOR,kBAAkB,CAACe,UAAU,CAACZ,cAAZ,EAA4BD,kBAA5B,CAAzB;AACD,CAXwE,CAAzE;;AAaA,OAAO,SAASsB,QAAT,CAAkBC,OAAlB,EAA2B;AAChC,QAAM;AACJd,IAAAA,OADI;AAEJe,IAAAA,MAFI;AAGJd,IAAAA,aAHI;AAIJV,IAAAA,kBAJI;AAKJyB,IAAAA;AALI,MAMFF,OANJ;AAOA,QAAMG,OAAO,GAAGF,MAAM,CAACG,MAAP,CAAc,CAACC,GAAD,EAAMpB,EAAN,KAAc,GAAEoB,GAAI,GAAErB,YAAY,CAACC,EAAD,EAAKC,OAAL,EAAcC,aAAd,EAA6BV,kBAA7B,CAAZ,CAA6DqB,IAA7D,CAAkErB,kBAAlE,CAAsF,MAA1H,EAAiI,EAAjI,EAAqI6B,IAArI,EAAhB;;AAEA,MAAI,CAACJ,cAAL,EAAqB;AACnB,WAAOC,OAAP;AACD;;AAED,QAAMI,OAAO,GAAI,GAAErB,OAAO,CAACsB,MAAR,CAAenB,MAAM,IAAIA,MAAM,CAACE,KAAP,KAAiBjB,+BAA+B,CAACiB,KAA1E,EAAiFH,GAAjF,CAAqFC,MAAM,IAAId,kBAAkB,CAACc,MAAM,CAACoB,UAAP,IAAqBpB,MAAM,CAACE,KAA7B,EAAoCd,kBAApC,CAAjH,EAA0KqB,IAA1K,CAA+KrB,kBAA/K,CAAmM,MAAtN;AACA,SAAQ,GAAE8B,OAAQ,GAAEJ,OAAQ,EAArB,CAAuBG,IAAvB,EAAP;AACD","sourcesContent":["import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\n\nconst serialiseCellValue = (value, delimiterCharacter) => {\n  if (typeof value === 'string') {\n    const formattedValue = value.replace(/\"/g, '\"\"'); // Make sure value containing delimiter or line break won't be split into multiple rows\n\n    if ([delimiterCharacter, '\\n', '\\r'].some(delimiter => formattedValue.includes(delimiter))) {\n      return `\"${formattedValue}\"`;\n    }\n\n    return formattedValue;\n  }\n\n  return value;\n};\n\nlet warnedOnce = false;\n\nconst serialiseRow = (id, columns, getCellParams, delimiterCharacter) => columns.map(column => {\n  const cellParams = getCellParams(id, column.field);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnce && String(cellParams.formattedValue) === '[object Object]') {\n      console.warn(['MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.'].join('\\n'));\n      warnedOnce = true;\n    }\n  }\n\n  return serialiseCellValue(cellParams.formattedValue, delimiterCharacter);\n});\n\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    getCellParams,\n    delimiterCharacter,\n    includeHeaders\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => `${acc}${serialiseRow(id, columns, getCellParams, delimiterCharacter).join(delimiterCharacter)}\\r\\n`, '').trim();\n\n  if (!includeHeaders) {\n    return CSVBody;\n  }\n\n  const CSVHead = `${columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field).map(column => serialiseCellValue(column.headerName || column.field, delimiterCharacter)).join(delimiterCharacter)}\\r\\n`;\n  return `${CSVHead}${CSVBody}`.trim();\n}"]},"metadata":{},"sourceType":"module"}