"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridEditing = useGridEditing;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _events = require("../../../models/events");

var _gridEditRowModel = require("../../../models/gridEditRowModel");

var _useGridApiEventHandler = require("../../utils/useGridApiEventHandler");

var _useGridApiMethod = require("../../utils/useGridApiMethod");

var _useGridLogger = require("../../utils/useGridLogger");

var _useGridStateInit = require("../../utils/useGridStateInit");

var _gridEditRowsSelector = require("./gridEditRowsSelector");

var _useGridCellEditing = require("./useGridCellEditing");

var _useGridRowEditing = require("./useGridRowEditing");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @requires useGridFocus - can be after, async only
 * @requires useGridParamsApi (method)
 * @requires useGridColumns (state)
 */
function useGridEditing(apiRef, props) {
  var _props$experimentalFe2;

  const logger = (0, _useGridLogger.useGridLogger)(apiRef, 'useGridEditRows');
  (0, _useGridCellEditing.useCellEditing)(apiRef, props);
  (0, _useGridRowEditing.useGridRowEditing)(apiRef, props);
  (0, _useGridStateInit.useGridStateInit)(apiRef, state => (0, _extends2.default)({}, state, {
    editRows: {}
  }));
  const debounceMap = React.useRef({});
  apiRef.current.unstable_updateControlState({
    stateId: 'editRows',
    propModel: props.editRowsModel,
    propOnChange: props.onEditRowsModelChange,
    stateSelector: _gridEditRowsSelector.gridEditRowsStateSelector,
    changeEvent: _events.GridEvents.editRowsModelChange
  });
  const isCellEditable = React.useCallback(params => !params.rowNode.isAutoGenerated && !!params.colDef.editable && !!params.colDef.renderEditCell && (!props.isCellEditable || props.isCellEditable(params)), // eslint-disable-next-line react-hooks/exhaustive-deps
  [props.isCellEditable]);

  const maybeDebounce = (id, field, debounceMs, callback) => {
    if (!debounceMs) {
      callback();
      return;
    }

    if (!debounceMap.current[id]) {
      debounceMap.current[id] = {};
    }

    if (debounceMap.current[id][field]) {
      const [timeout] = debounceMap.current[id][field];
      clearTimeout(timeout);
    }

    const callbackToRunImmediately = () => {
      callback();
      const [timeout] = debounceMap.current[id][field];
      clearTimeout(timeout);
      delete debounceMap.current[id][field];
    };

    const timeout = setTimeout(() => {
      callback();
      delete debounceMap.current[id][field];
    }, debounceMs);
    debounceMap.current[id][field] = [timeout, callbackToRunImmediately];
  };

  const runPendingEditCellValueChangeDebounce = React.useCallback((id, field) => {
    if (!debounceMap.current[id]) {
      return;
    }

    if (!field) {
      Object.keys(debounceMap.current[id]).forEach(debouncedField => {
        const [, callback] = debounceMap.current[id][debouncedField];
        callback();
      });
    } else if (debounceMap.current[id][field]) {
      const [, callback] = debounceMap.current[id][field];
      callback();
    }
  }, []);
  const setEditCellValue = React.useCallback((params, event = {}) => {
    maybeDebounce(params.id, params.field, params.debounceMs, () => {
      var _props$experimentalFe;

      if ((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.preventCommitWhileValidating) {
        if (props.editMode === 'row') {
          return apiRef.current.unstable_setRowEditingEditCellValue(params);
        }

        return apiRef.current.unstable_setCellEditingEditCellValue(params);
      }

      const newParams = {
        id: params.id,
        field: params.field,
        props: {
          value: params.value
        }
      };
      return apiRef.current.publishEvent(_events.GridEvents.editCellPropsChange, newParams, event);
    });
  }, [apiRef, props.editMode, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.preventCommitWhileValidating]);
  const parseValue = React.useCallback((id, field, value) => {
    const column = apiRef.current.getColumn(field);
    return column.valueParser ? column.valueParser(value, apiRef.current.getCellParams(id, field)) : value;
  }, [apiRef]);
  const setEditCellProps = React.useCallback(params => {
    const {
      id,
      field,
      props: editProps
    } = params;
    logger.debug(`Setting cell props on id: ${id} field: ${field}`);
    apiRef.current.setState(state => {
      const editRowsModel = (0, _extends2.default)({}, state.editRows);
      editRowsModel[id] = (0, _extends2.default)({}, state.editRows[id]);
      editRowsModel[id][field] = (0, _extends2.default)({}, editProps, {
        value: parseValue(id, field, editProps.value)
      });
      return (0, _extends2.default)({}, state, {
        editRows: editRowsModel
      });
    });
    apiRef.current.forceUpdate();
    const editRowsState = (0, _gridEditRowsSelector.gridEditRowsStateSelector)(apiRef.current.state);
    return editRowsState[id][field];
  }, [apiRef, logger, parseValue]);
  const setEditRowsModel = React.useCallback(model => {
    const currentModel = (0, _gridEditRowsSelector.gridEditRowsStateSelector)(apiRef.current.state);

    if (currentModel !== model) {
      logger.debug(`Setting editRows model`);
      apiRef.current.setState(state => (0, _extends2.default)({}, state, {
        editRows: model
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const getEditRowsModel = React.useCallback(() => (0, _gridEditRowsSelector.gridEditRowsStateSelector)(apiRef.current.state), [apiRef]);
  const preventTextSelection = React.useCallback((params, event) => {
    const isMoreThanOneClick = event.detail > 1;

    if (params.isEditable && params.cellMode === _gridEditRowModel.GridCellModes.View && isMoreThanOneClick) {
      // If we click more than one time, then we prevent the default behavior of selecting the text cell.
      event.preventDefault();
    }
  }, []);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.cellMouseDown, preventTextSelection);
  (0, _useGridApiEventHandler.useGridApiOptionHandler)(apiRef, _events.GridEvents.editCellPropsChange, props.onEditCellPropsChange); // TODO v6: remove, use `preProcessEditCellProps` instead

  const editingSharedApi = {
    isCellEditable,
    setEditRowsModel,
    getEditRowsModel,
    setEditCellValue,
    unstable_setEditCellProps: setEditCellProps,
    unstable_parseValue: parseValue,
    unstable_runPendingEditCellValueChangeDebounce: runPendingEditCellValueChangeDebounce
  };
  (0, _useGridApiMethod.useGridApiMethod)(apiRef, editingSharedApi, 'EditRowApi');
  React.useEffect(() => {
    if (props.editRowsModel !== undefined) {
      apiRef.current.setEditRowsModel(props.editRowsModel);
    }
  }, [apiRef, props.editRowsModel]);
}