"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGridSelection = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _events = require("../../../models/events");

var _useGridApiEventHandler = require("../../utils/useGridApiEventHandler");

var _useGridApiMethod = require("../../utils/useGridApiMethod");

var _useGridLogger = require("../../utils/useGridLogger");

var _gridRowsSelector = require("../rows/gridRowsSelector");

var _domUtils = require("../../../utils/domUtils");

var _gridSelectionSelector = require("./gridSelectionSelector");

var _pagination = require("../pagination");

var _gridFilterSelector = require("../filter/gridFilterSelector");

var _colDef = require("../../../colDef");

var _useGridStateInit = require("../../utils/useGridStateInit");

var _gridEditRowModel = require("../../../models/gridEditRowModel");

var _keyboardUtils = require("../../../utils/keyboardUtils");

var _useCurrentPageRows = require("../../utils/useCurrentPageRows");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @requires useGridRows (state, method)
 * @requires useGridParamsApi (method)
 */
const useGridSelection = (apiRef, props) => {
  const logger = (0, _useGridLogger.useGridLogger)(apiRef, 'useGridSelection');
  const propSelectionModel = React.useMemo(() => {
    if (props.selectionModel == null) {
      return props.selectionModel;
    }

    if (Array.isArray(props.selectionModel)) {
      return props.selectionModel;
    }

    return [props.selectionModel];
  }, [props.selectionModel]);
  (0, _useGridStateInit.useGridStateInit)(apiRef, state => (0, _extends2.default)({}, state, {
    selection: propSelectionModel != null ? propSelectionModel : []
  }));
  const lastRowToggled = React.useRef(null);
  apiRef.current.unstable_updateControlState({
    stateId: 'selection',
    propModel: propSelectionModel,
    propOnChange: props.onSelectionModelChange,
    stateSelector: _gridSelectionSelector.gridSelectionStateSelector,
    changeEvent: _events.GridEvents.selectionChange
  });
  const {
    checkboxSelection,
    disableMultipleSelection,
    disableSelectionOnClick,
    isRowSelectable,
    pagination,
    paginationMode
  } = props;
  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;
  const expandRowRangeSelection = React.useCallback(id => {
    var _lastRowToggled$curre;

    let endId = id;
    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;
    const isSelected = apiRef.current.isRowSelected(id);

    if (isSelected) {
      const visibleRowIds = (0, _gridFilterSelector.gridVisibleSortedRowIdsSelector)(apiRef);
      const startIndex = visibleRowIds.findIndex(rowId => rowId === startId);
      const endIndex = visibleRowIds.findIndex(rowId => rowId === endId);

      if (startIndex > endIndex) {
        endId = visibleRowIds[endIndex + 1];
      } else {
        endId = visibleRowIds[endIndex - 1];
      }
    }

    lastRowToggled.current = id;
    apiRef.current.selectRowRange({
      startId,
      endId
    }, !isSelected);
  }, [apiRef]);
  /**
   * API METHODS
   */

  const setSelectionModel = React.useCallback(model => {
    const currentModel = (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state);

    if (currentModel !== model) {
      logger.debug(`Setting selection model`);
      apiRef.current.setState(state => (0, _extends2.default)({}, state, {
        selection: model
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const isRowSelected = React.useCallback(id => (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state).includes(id), [apiRef]);
  const getSelectedRows = React.useCallback(() => (0, _gridSelectionSelector.selectedGridRowsSelector)(apiRef), [apiRef]);
  const selectRow = React.useCallback((id, isSelected = true, resetSelection = false) => {
    if (isRowSelectable && !isRowSelectable(apiRef.current.getRowParams(id))) {
      return;
    }

    lastRowToggled.current = id;

    if (resetSelection) {
      logger.debug(`Setting selection for row ${id}`);
      apiRef.current.setSelectionModel(isSelected ? [id] : []);
    } else {
      logger.debug(`Toggling selection for row ${id}`);
      const selection = (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state);
      const newSelection = selection.filter(el => el !== id);

      if (isSelected) {
        newSelection.push(id);
      }

      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;

      if (isSelectionValid) {
        apiRef.current.setSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, logger, canHaveMultipleSelection]);
  const selectRows = React.useCallback((ids, isSelected = true, resetSelection = false) => {
    logger.debug(`Setting selection for several rows`);
    const selectableIds = isRowSelectable ? ids.filter(id => isRowSelectable(apiRef.current.getRowParams(id))) : ids;
    let newSelection;

    if (resetSelection) {
      newSelection = isSelected ? selectableIds : [];
    } else {
      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project
      const selectionLookup = (0, _extends2.default)({}, (0, _gridSelectionSelector.selectedIdsLookupSelector)(apiRef));
      selectableIds.forEach(id => {
        if (isSelected) {
          selectionLookup[id] = id;
        } else {
          delete selectionLookup[id];
        }
      });
      newSelection = Object.values(selectionLookup);
    }

    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;

    if (isSelectionValid) {
      apiRef.current.setSelectionModel(newSelection);
    }
  }, [apiRef, isRowSelectable, logger, canHaveMultipleSelection]);
  const selectRowRange = React.useCallback(({
    startId,
    endId
  }, isSelected = true, resetSelection) => {
    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {
      return;
    }

    logger.debug(`Expanding selection from row ${startId} to row ${endId}`);
    const visibleRowIds = (0, _gridFilterSelector.gridVisibleSortedRowIdsSelector)(apiRef);
    const startIndex = visibleRowIds.indexOf(startId);
    const endIndex = visibleRowIds.indexOf(endId);
    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];
    const rowsBetweenStartAndEnd = visibleRowIds.slice(start, end + 1);
    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);
  }, [apiRef, logger]);
  const selectionApi = {
    selectRow,
    selectRows,
    selectRowRange,
    setSelectionModel,
    getSelectedRows,
    isRowSelected
  };
  (0, _useGridApiMethod.useGridApiMethod)(apiRef, selectionApi, 'GridSelectionApi');
  /**
   * EVENTS
   */

  const removeOutdatedSelection = React.useCallback(() => {
    const currentSelection = (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state);
    const rowsLookup = (0, _gridRowsSelector.gridRowsLookupSelector)(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project

    const selectionLookup = (0, _extends2.default)({}, (0, _gridSelectionSelector.selectedIdsLookupSelector)(apiRef));
    let hasChanged = false;
    currentSelection.forEach(id => {
      if (!rowsLookup[id]) {
        delete selectionLookup[id];
        hasChanged = true;
      }
    });

    if (hasChanged) {
      apiRef.current.setSelectionModel(Object.values(selectionLookup));
    }
  }, [apiRef]);
  const handleSingleRowSelection = React.useCallback((id, event) => {
    const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:
    // - it is a checkboxSelection
    // - it is a keyboard selection
    // - CTRL is pressed

    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !(0, _keyboardUtils.isKeyboardEvent)(event);
    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;
    const isSelected = apiRef.current.isRowSelected(id);

    if (resetSelection) {
      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);
    } else {
      apiRef.current.selectRow(id, !isSelected, false);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);
  const handleCellClick = React.useCallback((params, event) => {
    if (disableSelectionOnClick) {
      return;
    }

    if (params.field === _colDef.GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      // click on checkbox should not trigger row selection
      return;
    }

    if (params.field === '__detail_panel_toggle__') {
      // click to open the detail panel should not select the row
      return;
    }

    if (params.field) {
      const column = apiRef.current.getColumn(params.field);

      if (column.type === _colDef.GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }

    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {
      expandRowRangeSelection(params.id);
    } else {
      handleSingleRowSelection(params.id, event);
    }
  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandRowRangeSelection, handleSingleRowSelection]);
  const preventSelectionOnShift = React.useCallback((params, event) => {
    if (canHaveMultipleSelection && event.shiftKey) {
      var _window$getSelection;

      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();
    }
  }, [canHaveMultipleSelection]);
  const handleRowSelectionCheckboxChange = React.useCallback((params, event) => {
    if (event.nativeEvent.shiftKey) {
      expandRowRangeSelection(params.id);
    } else {
      apiRef.current.selectRow(params.id, params.value);
    }
  }, [apiRef, expandRowRangeSelection]);
  const handleHeaderSelectionCheckboxChange = React.useCallback(params => {
    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;
    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? (0, _pagination.gridPaginatedVisibleSortedGridRowIdsSelector)(apiRef) : (0, _gridFilterSelector.gridVisibleSortedRowIdsSelector)(apiRef);
    apiRef.current.selectRows(rowsToBeSelected, params.value);
  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);
  const handleCellKeyDown = React.useCallback((params, event) => {
    // Ignore portal
    // Do not apply shortcuts if the focus is not on the cell root component
    // TODO replace with !event.currentTarget.contains(event.target as Element)
    if (!(0, _domUtils.isGridCellRoot)(event.target)) {
      return;
    } // Get the most recent params because the cell mode may have changed by another listener


    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    const isEditMode = cellParams.cellMode === _gridEditRowModel.GridCellModes.Edit;

    if (isEditMode) {
      return;
    }

    if (event.key === ' ' && event.shiftKey) {
      event.preventDefault();
      handleSingleRowSelection(cellParams.id, event);
      return;
    }

    if (event.key.toLowerCase() === 'a' && (event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      selectRows(apiRef.current.getAllRowIds(), true);
    }
  }, [apiRef, handleSingleRowSelection, selectRows]);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.visibleRowsSet, removeOutdatedSelection);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.cellClick, handleCellClick);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.rowSelectionCheckboxChange, handleRowSelectionCheckboxChange);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.headerSelectionCheckboxChange, handleHeaderSelectionCheckboxChange);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.cellMouseDown, preventSelectionOnShift);
  (0, _useGridApiEventHandler.useGridApiEventHandler)(apiRef, _events.GridEvents.cellKeyDown, handleCellKeyDown);
  /**
   * EFFECTS
   */

  React.useEffect(() => {
    if (propSelectionModel !== undefined) {
      apiRef.current.setSelectionModel(propSelectionModel);
    }
  }, [apiRef, propSelectionModel]);
  const isStateControlled = propSelectionModel != null;
  React.useEffect(() => {
    if (isStateControlled) {
      return;
    } // isRowSelectable changed


    const currentSelection = (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state);

    if (isRowSelectable) {
      const newSelection = currentSelection.filter(id => isRowSelectable(apiRef.current.getRowParams(id)));

      if (newSelection.length < currentSelection.length) {
        apiRef.current.setSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, isStateControlled]);
  React.useEffect(() => {
    const currentSelection = (0, _gridSelectionSelector.gridSelectionStateSelector)(apiRef.current.state);

    if (!canHaveMultipleSelection && currentSelection.length > 1) {
      const {
        rows: currentPageRows
      } = (0, _useCurrentPageRows.getCurrentPageRows)(apiRef, {
        pagination,
        paginationMode
      });
      const currentPageRowsLookup = currentPageRows.reduce((acc, {
        id
      }) => {
        acc[id] = true;
        return acc;
      }, {});
      const firstSelectableRow = currentSelection.find(id => {
        let isSelectable = true;

        if (isRowSelectable) {
          isSelectable = isRowSelectable(apiRef.current.getRowParams(id));
        }

        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page
      });
      apiRef.current.setSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);
};

exports.useGridSelection = useGridSelection;